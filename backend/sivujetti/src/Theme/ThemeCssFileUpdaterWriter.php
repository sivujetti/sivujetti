<?php declare(strict_types=1);

namespace Sivujetti\Theme;

use Pike\{PikeException};
use Sivujetti\{FileSystem};

final class ThemeCssFileUpdaterWriter {
    /** @var \Sivujetti\FileSystem */
    private FileSystem $fs;
    /**
     * @param \Sivujetti\FileSystem $fs
     */
    public function __construct(FileSystem $fs) {
        $this->fs = $fs;
    }
    /**
     * Overwrites $blockTypeName's base styles from SIVUJETTI_INDEX_PATH . "public/{$themeName}-generated.css".
     * Note: mutates $currentStylesAll.
     *
     * @param string $blockTypeName
     * @param string $updatedStyles
     * @param object $currentStylesAll
     * @param string $themeName
     */
    public function overwriteBlockTypeBaseStylesToDisk(string $blockTypeName,
                                                       string $updatedStyles,
                                                       object $currentStylesAll,
                                                       string $themeName): void {
        $currentStylesAll->generatedBlockTypeBaseCss = self::replaceLinesBetween(
            from: $currentStylesAll->generatedBlockTypeBaseCss,
            withLines: self::compileCss($updatedStyles, "[data-block-type=\"{$blockTypeName}\"]"),
            startLine: "/* >> Base styles for block type \"{$blockTypeName}\" start */\n",
            endLine: "/* << Base styles for block type \"{$blockTypeName}\" end */\n"
        );
        // @allow \Pike\PikeException
        $this->overwriteAllToDisk($currentStylesAll, $themeName);
    }
    /**
     * Overwrites $blockId's styles from SIVUJETTI_INDEX_PATH . "public/{$themeName}-generated.css".
     * Note: mutates $currentStylesAll.
     *
     * @param object[] $updatedStyles
     * @param object $currentStylesAll
     * @param string $themeName
     */
    public function overwriteBlockStylesToDisk(array $updatedStyles,
                                               object $currentStylesAll,
                                               string $themeName): void {
        // Mutates $currentStylesAll->generatedBlockCss count($updateStyles) times
        foreach ($updatedStyles as $style) {
            $blockId = $style->blockId;
            $currentStylesAll->generatedBlockCss = self::addOrReplaceLines(
                from: $currentStylesAll->generatedBlockCss,
                withLines: self::compileBlockCss($style),
                startLine: "/* >> Styles for individual block \"{$blockId}\" start */\n",
                endLine: "/* << Styles for individual block \"{$blockId}\" end */\n"
            );
        }
        // @allow \Pike\PikeException
        $this->overwriteAllToDisk($currentStylesAll, $themeName);
    }
    /**
     * @param object $styles
     * @return string
     */
    public static function compileBlockTypeBaseCss(object $styles): string {
        return self::compileCss($styles->styles, "[data-block-type=\"{$styles->blockTypeName}\"]");
    }
    /**
     * @param object $styles
     * @return string
     */
    public static function compileBlockCss(object $styles): string {
        return self::compileCss($styles->styles, "[data-block=\"{$styles->blockId}\"]");
    }
    /**
     * @param object $stylesAll
     * @param string $themeName
     */
    private function overwriteAllToDisk(object $stylesAll, string $themeName): void {
        // @allow \Pike\PikeException
        $this->fs->write(SIVUJETTI_INDEX_PATH . "public/{$themeName}-generated.css", (
            "/* Generated by Sivujetti at " . gmdate("D, M d Y H:i:s e", time()) . " */\n\n".
            "/* > Base styles for block all types start */\n" .
            $stylesAll->generatedBlockTypeBaseCss .
            "/* < Base styles for block all types end */\n\n" .
            "/* > Styles for all individual blocks start */\n" .
            $stylesAll->generatedBlockCss .
            "/* < Styles for all individual blocks end */\n"
        ));
    }
    /**
     * @param string $input
     * @param string $selector
     * @return string
     */
    private static function compileCss(string $input, string $selector): string {
        $withLfEndings = $input ? str_replace("\r", "", $input) : "{ }\n";
        $withNewline = $withLfEndings[-1] === "\n" ? $withLfEndings : "{$withLfEndings}\n";
        return $selector . str_replace("[[scope]]", $selector, $withNewline);
    }
    /**
     * @param string $from The haystack
     * @param string $withLines
     * @param string $startLine
     * @param string $endLine
     * @return string
     */
    private static function addOrReplaceLines(string $from,
                                              string $withLines,
                                              string $startLine,
                                              string $endLine): string {
        $startLineStartPos = strpos($from, $startLine);
        if ($startLineStartPos !== false) {
            return self::replaceLinesBetween($from, $withLines, $startLine, $endLine, $startLineStartPos);
        }
        return "{$from}{$startLine}{$withLines}{$endLine}";
    }
    /**
     * Replaces every line between $startLine and $endLine with $startLine + $withLines
     * from $from.
     *
     * @param string $from The haystack
     * @param string $withLines Lines to add after $startLine
     * @param string $startLine Add $withLines after this line or offset
     * @param string $endLine
     * @param ?int $startLineStartPos = null
     * @return string
     * @throws \Pike\PikeException If $from doesn't contain $startLine or $endLine
     */
    private static function replaceLinesBetween(string $from,
                                                string $withLines,
                                                string $startLine,
                                                string $endLine,
                                                ?int $startLineStartPos = null): string {
        if ($startLineStartPos === null && ($startLineStartPos = strpos($from, $startLine)) === false)
            throw new PikeException("\$from doesn't contain line `{$startLine}`",
                                    PikeException::ERROR_EXCEPTION);
        $beginningOfLineAfterStartLinePos = $startLineStartPos + strlen($startLine);
        $endLineStartPos = strpos($from, $endLine, $beginningOfLineAfterStartLinePos);
        if ($endLineStartPos === false)
            throw new PikeException("\$from doesn't contain line `{$endLine}`",
                                    PikeException::ERROR_EXCEPTION);
        return (
            substr($from, 0, $beginningOfLineAfterStartLinePos) .
            $withLines .
            substr($from, $endLineStartPos)
        );
    }
}
